#pragma once

#include <vector>
#include <memory>
#include <string>
#include <stdexcept>
#include "Token.h"
#include "AST.h"
#include "CodeGenerator.h"

// The Parser class uses a series of tokens to construct an Abstract Syntax Tree (AST)
// by recursively parsing expressions according to the grammar of the language.
class Parser {
public:
    // Constructor that initializes the parser with a vector of tokens.
    explicit Parser(const std::vector<Token>& tokens);

    // Parses the tokens into an AST and returns the root of the AST.
    void parse();

private:
    // The list of tokens generated by the lexer.
    const std::vector<Token>& tokens;
    // Current position in the token vector.
    size_t current = 0;

    // Utility methods to facilitate the parsing process:
    bool match(std::initializer_list<TokenType> types); // Checks if the current token matches any in the list and advances.
    bool check(TokenType type) const;                   // Checks if the current token is of the given type.
    Token advance();                                    // Consumes the current token and returns it.
    bool isAtEnd() const;                               // Checks if the current token is the end of file indicator.
    Token peek() const;                                 // Returns the current token without consuming it.
    Token previous() const;                             // Returns the token before the current one.
    void consume(TokenType type, const std::string& message); // Consumes a token of a specific type or throws an error.

    std::unique_ptr<ExprNode> expression();  // Entry point for expression parsing
    std::unique_ptr<ExprNode> logicalOr();   // Handles the logical OR
    std::unique_ptr<ExprNode> logicalAnd();  // Handles the logical AND
    std::unique_ptr<ExprNode> equality();    // Handles == and !=
    std::unique_ptr<ExprNode> comparison();  // Handles <, >, <=, >=
    std::unique_ptr<ExprNode> term();        // Handles +, -
    std::unique_ptr<ExprNode> factor();      // Handles *, /
    std::unique_ptr<ExprNode> unary();       // Handles unary operators like - and !
    std::unique_ptr<ExprNode> primary();     // Handles numbers and parentheses

    void synchronize();

};
